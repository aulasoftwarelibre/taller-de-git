{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"<p>Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba.</p> <p>El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias.</p>"},{"location":"#contenido","title":"Contenido","text":"<ul> <li>Inicio</li> <li>Sistemas de control de versiones</li> <li>Introducci\u00f3n a Git</li> <li>Aspectos b\u00e1sicos de Git</li> <li>Uso b\u00e1sico</li> <li>Uso avanzado</li> <li>Ramas</li> <li>Administraci\u00f3n de repositorios</li> <li>Flujo de trabajo con Git (git flow)</li> <li>Github</li> <li>Referencias</li> </ul>"},{"location":"#agradecimientos","title":"Agradecimientos","text":"<p>Este curso ha sido impartido por las siguientes personas:</p> <ul> <li>Adri\u00e1n L\u00f3pez</li> <li>H\u00e9ctor Romero</li> <li>Javier de Santiago</li> <li>Jos\u00e9 M\u00e1rquez</li> <li>Sergio G\u00f3mez</li> <li>Alba Palomino</li> </ul>"},{"location":"#licencia","title":"Licencia","text":"<p>El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)</p>"},{"location":"commands/","title":"Comandos de git","text":"<p>Esta secci\u00f3n describe algunos de los comandos m\u00e1s interesantes de git</p>"},{"location":"commands/#git-stash-reserva","title":"Git stash (reserva)","text":"<p>La orden <code>git stash</code> nos permite salvar moment\u00e1neamente el espacio de trabajo cuando tenemos que cambiar de rama o preparar la rama actual para sincronizar cambios.</p> <p>Las operaciones m\u00e1s importantes que podemos hacer con <code>git stash</code> son:</p>"},{"location":"commands/#git-stash-save","title":"git stash save","text":"<p>Es equivalente a poner solo <code>git stash</code> pero nos permite realizar m\u00e1s acciones como:</p> <pre><code>git stash save \"Tu mensaje\"\ngit stash save -u\n</code></pre> <p>El par\u00e1metro <code>-u</code> permite que se almacen tambi\u00e9n los ficheros sin seguimiento previo (untracked en ingl\u00e9s, aquellos ficheros que no se han metido nunca en el repositorio).</p>"},{"location":"commands/#git-stash-list","title":"git stash list","text":"<p>Permite mostrar la pila del stash.</p> <pre><code>$ git stash list\nstash@{0}: On main: Stash con mensaje\nstash@{1}: WIP on main: 4ab21df First commit\n</code></pre>"},{"location":"commands/#git-stash-apply","title":"git stash apply","text":"<p>Esta orden coge el stash que est\u00e1 arriba en la pila y lo aplica al espacio de trabajo actual. En este caso siempre es <code>stash@{0}</code>. El stash permanece en la pila.</p> <p>Se puede indicar como par\u00e1metro un stash en concreto.</p>"},{"location":"commands/#git-stash-pop","title":"git stash pop","text":"<p>Funciona igual que <code>git apply</code> con la diferencia de que el stash s\u00ed se borra de la pila.</p>"},{"location":"commands/#git-stash-show","title":"git stash show","text":"<p>Muestra un resumen de los ficheros que se han modificado en ese stash.</p> <pre><code>$ git stash show\nA.txt | 1 +\nB.txt | 3 +++\n2 file changed, 4 insertions(+)\n</code></pre> <p>Para ver los cambios podemos usar el par\u00e1metro <code>-p</code></p> <pre><code>$ git stash show -p\n--- a/A.txt\n+++ b/A.txt\n@@ -45,6 +45,7 @@ nav:\n+ This is a change\n</code></pre> <p>Por defecto siempre muestra la cabeza de la pila. Igual que en casos anteriores podemos indicar un stash en concreto.</p> <pre><code>$ git stash show stash@{1}\n</code></pre>"},{"location":"commands/#git-stash-branch","title":"git stash branch","text":"<p>Permite crear una nueva rama a partir del \u00faltimo stash. Adem\u00e1s, el mismo es borrado de la pila. Se puede especificar uno en concreto si lo queremos, como en el resto de comandos.</p> <pre><code>git stash branch nombre-de-nueva-rama stash@{1}\n</code></pre>"},{"location":"commands/#git-stash-clear","title":"git stash clear","text":"<p>Este comando borrar todos los stash de la pila. Es destructiva y no se puede deshacer.</p>"},{"location":"commands/#git-stash-drop","title":"git stash drop","text":"<p>Permite borrar un stash en concreto (o el \u00faltimo si no se indica ninguno). Como con clear, borrarlo implica que no se puede recuperar.</p>"},{"location":"commands/#git-worktree","title":"Git worktree","text":"<p>Uno de los problemas m\u00e1s habituales es tener que tocar una rama distinta a la que tenemos actualmente. Eso implica que si estamos en medio de un trabajo tendr\u00edamos que hacer un commit o un stash, lo cual a veces es bastante molesto.</p> <p>Con <code>git worktree</code> podemos crear un directorio de trabajo que contenga otra rama distinta, de forma temporal. No supone otro clon del repositorio porque ambos usan el mismo.</p>"},{"location":"commands/#git-worktree-add","title":"git worktree add","text":"<p>Esta funci\u00f3n es la que crea el espacio de trabajo temporal. Imaginemos que estamos en una rama llamada <code>develop</code>:</p> <pre><code>$ git worktree add ../project-main main\n$ git worktree add -b fix ../project-fix main\n</code></pre> <p>La primera orden crea un directorio llamado project-main que contiene el estado de main. La segunda, que contiene el par\u00e1metro <code>-b</code> equivale a crear una nueva rama llamada fix, que se crea desde main (suponemos que no existe fix).</p>"},{"location":"commands/#git-worktree-list","title":"git worktree list","text":"<p>Muestra el listado de directorios y espacios de trabajo.</p> <pre><code>$git worktree list\n/home/sergio/taller-de-git  3b63b4b [main]\n/home/sergio/fix           3b63b4b [fix]\n</code></pre>"},{"location":"commands/#git-worktree-remove","title":"git worktree remove","text":"<p>Borrar un espacio de trabajo. Hay que indicar el nombre entre corchetes que aparece en el listado</p> <pre><code>$ git worktree delete fix\n</code></pre>"},{"location":"commands/#git-worktree-prune","title":"git worktree prune","text":"<p>Una cuesti\u00f3n importante, es que las ramas que est\u00e9n desplegadas en otro espacio de trabajo, se encuentran bloqueadas y no se pueden desbloquear en otro distinto.</p> <p>Esto significa que si estamos trabajando en la rama developer, creamos otro worktree en otro directorio de la rama main, no podemos hacer pasar a main. No es posible tener la misma rama en varios espacios de trabajo.</p> <p>Si se ha borrado el directorio a mano (en vez de usando remove), eso no implica que el bloqueo desparezca. Con esta orden podemos hacer que git compruebe que los espacios de trabajo secundario se comprueben de nuevo para ver si siguen existiendo y se elimine el bloqueo.</p>"},{"location":"commands/#git-blame","title":"Git blame","text":"<p>Lo ideal en un equipo de desarrollo es que el c\u00f3digo pase por todas las manos para as\u00ed mejorar su calidad.</p> <p>Con git blame podemos saber qui\u00e9n fue el \u00faltimo en modificar una l\u00ednea concreta de c\u00f3digo, en qu\u00e9 commit y en qu\u00e9 fecha lo hizo.</p> <pre><code>$ git blame ejemplo.php\n33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100  8)   name: \"material\"\n33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100  9)   language: \"es\"\n</code></pre>"},{"location":"cvs/","title":"Sistemas de control de versiones","text":""},{"location":"cvs/#definicion-clasificacion-y-funcionamiento","title":"Definici\u00f3n, clasificaci\u00f3n y funcionamiento","text":"<p>Se llama control de versiones a la gesti\u00f3n de los diversos cambios que se realizan sobre los elementos de alg\u00fan producto o una configuraci\u00f3n del mismo. Una versi\u00f3n, revisi\u00f3n o edici\u00f3n de un producto, es el estado en el que se encuentra dicho producto en un momento dado de su desarrollo o modificaci\u00f3n. Aunque un sistema de control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gesti\u00f3n dando lugar a los llamados sistemas de control de versiones o SVC (del ingl\u00e9s System Version Control).</p> <p>Estos sistemas facilitan la administraci\u00f3n de las distintas versiones de cada producto desarrollado, as\u00ed como las posibles especializaciones realizadas (por ejemplo, para alg\u00fan cliente espec\u00edfico). Ejemplos de este tipo de herramientas son entre otros: CVS, Subversion, SourceSafe, ClearCase, Darcs, Bazaar , Plastic SCM, Git, Mercurial, Perforce.</p>"},{"location":"cvs/#terminologia","title":"Terminolog\u00eda","text":"Repositorio (\"repository\") El repositorio es el lugar en el que se almacenan los datos actualizados e hist\u00f3ricos de cambios. Revisi\u00f3n (\"revision\") Una revisi\u00f3n es una versi\u00f3n determinada de la informaci\u00f3n que se gestiona. Hay sistemas que identifican las revisiones con un contador (Ej. subversion). Hay otros sistemas que identifican las revisiones mediante un c\u00f3digo de detecci\u00f3n de modificaciones (Ej. git usa SHA1). Etiqueta (\"tag\") Los tags permiten identificar de forma f\u00e1cil revisiones importantes en el proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las versiones publicadas del proyecto. Rama (\"branch\") Un conjunto de archivos puede ser ramificado o bifurcado en un punto en el tiempo de manera que, a partir de ese momento, dos copias de esos archivos se pueden desarrollar a velocidades diferentes o en formas diferentes de forma independiente el uno del otro. Cambio (\"change\") Un cambio (o diff, o delta) representa una modificaci\u00f3n espec\u00edfica de un documento bajo el control de versiones. La granularidad de la modificaci\u00f3n que es considerada como un cambio var\u00eda entre los sistemas de control de versiones. Desplegar (\"checkout\") Es crear una copia de trabajo local desde el repositorio. Un usuario puede especificar una revisi\u00f3n en concreto u obtener la \u00faltima. El t\u00e9rmino 'checkout' tambi\u00e9n se puede utilizar como un sustantivo para describir la copia de trabajo. Confirmar (\"commit\") Confirmar es escribir o mezclar los cambios realizados en la copia de trabajo del repositorio. Los t\u00e9rminos 'commit' y 'checkin' tambi\u00e9n se pueden utilizar como sustantivos para describir la nueva revisi\u00f3n que se crea como resultado de confirmar. Conflicto (\"conflict\") Un conflicto se produce cuando diferentes partes realizan cambios en el mismo documento, y el sistema es incapaz de conciliar los cambios. Un usuario debe resolver el conflicto mediante la integraci\u00f3n de los cambios, o mediante la selecci\u00f3n de un cambio en favor del otro. Cabeza (\"head\") Tambi\u00e9n a veces se llama tip (punta) y se refiere a la \u00faltima confirmaci\u00f3n, ya sea en el tronco ('trunk') o en una rama ('branch'). El tronco y cada rama tienen su propia cabeza, aunque HEAD se utiliza a veces libremente para referirse al tronco. Tronco (\"trunk\") La \u00fanica l\u00ednea de desarrollo que no es una rama (a veces tambi\u00e9n llamada l\u00ednea base, l\u00ednea principal o m\u00e1ster). Fusionar, integrar, mezclar (\"merge\") Una fusi\u00f3n o integraci\u00f3n es una operaci\u00f3n en la que se aplican dos tipos de cambios en un archivo o conjunto de archivos. Algunos escenarios de ejemplo son los siguientes: <ul> <li>Un usuario, trabajando en un conjunto de archivos, actualiza o sincroniza su copia de trabajo con los cambios realizados y confirmados, por otros usuarios, en el repositorio.</li> <li>Un usuario intenta confirmar archivos que han sido actualizado por otros usuarios desde el \u00faltimo despliegue ('checkout'), y el software de control de versiones integra autom\u00e1ticamente los archivos (por lo general, despu\u00e9s de preguntarle al usuario si se debe proceder con la integraci\u00f3n autom\u00e1tica, y en algunos casos s\u00f3lo se hace si la fusi\u00f3n puede ser clara y razonablemente resuelta).</li> <li>Un conjunto de archivos se bifurca, un problema que exist\u00eda antes de la ramificaci\u00f3n se trabaja en una nueva rama, y la soluci\u00f3n se combina luego en la otra rama.</li> <li>Se crea una rama, el c\u00f3digo de los archivos es independiente editado, y la rama actualizada se incorpora m\u00e1s tarde en un \u00fanico tronco unificado.</li> </ul>"},{"location":"cvs/#clasificacion","title":"Clasificaci\u00f3n","text":"<p>Podemos clasificar los sistemas de control de versiones atendiendo a la arquitectura utilizada para el almacenamiento del c\u00f3digo: locales, centralizados y distribuidos.</p>"},{"location":"cvs/#locales","title":"Locales","text":"<p>Los cambios son guardados localmente y no se comparten con nadie. Esta arquitectura es la antecesora de las dos siguientes.</p> <p></p>"},{"location":"cvs/#centralizados","title":"Centralizados","text":"<p>Existe un repositorio centralizado de todo el c\u00f3digo, del cual es responsable un \u00fanico usuario (o conjunto de ellos). Se facilitan las tareas administrativas a cambio de reducir flexibilidad, pues todas las decisiones fuertes (como crear una nueva rama) necesitan la aprobaci\u00f3n del responsable. Algunos ejemplos son CVS y Subversion.</p> <p></p>"},{"location":"cvs/#distribuidos","title":"Distribuidos","text":"<p>Cada usuario tiene su propio repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Es frecuente el uso de un repositorio, que est\u00e1 normalmente disponible, que sirve de punto de sincronizaci\u00f3n de los distintos repositorios locales. Ejemplos: Git y Mercurial.</p> <p></p>"},{"location":"cvs/#ventajas-de-sistemas-distribuidos","title":"Ventajas de sistemas distribuidos","text":"<ul> <li>No es necesario estar conectado para guardar cambios.</li> <li>Posibilidad de continuar trabajando si el repositorio remoto no est\u00e1 accesible.</li> <li>El repositorio central est\u00e1 m\u00e1s libre de ramas de pruebas.</li> <li>Se necesitan menos recursos para el repositorio remoto.</li> <li>M\u00e1s flexibles al permitir gestionar cada repositorio personal como se quiera.</li> </ul>"},{"location":"git/","title":"Aspectos b\u00e1sicos de Git","text":""},{"location":"git/#instalacion","title":"Instalaci\u00f3n","text":""},{"location":"git/#instalando-en-linux","title":"Instalando en Linux","text":"<p>Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum:</p> <pre><code>$ yum install git-core\n</code></pre> <p>O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get:</p> <pre><code>$ apt-get install git\n</code></pre>"},{"location":"git/#instalando-en-windows","title":"Instalando en Windows","text":"<p>Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo:</p> <p>http://msysgit.github.com/</p> <p>Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador.</p>"},{"location":"git/#instalando-en-macos","title":"Instalando en MacOS","text":"<p>En MacOS se recomienda tener instalada la herramienta homebrew. Despu\u00e9s, es tan f\u00e1cil como ejecutar:</p> <pre><code>$ brew install git\n</code></pre>"},{"location":"git/#configuracion","title":"Configuraci\u00f3n","text":""},{"location":"git/#tu-identidad","title":"Tu identidad","text":"<p>Lo primero que deber\u00edas hacer cuando instalas Git es establecer tu nombre de usuario y direcci\u00f3n de correo electr\u00f3nico. Esto es importante porque las confirmaciones de cambios (commits) en Git usan esta informaci\u00f3n, y es introducida de manera inmutable en los commits que env\u00edas:</p> <pre><code>$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n</code></pre> <p>Tambi\u00e9n se recomienda configurar el siguiente par\u00e1metro:</p> <pre><code>$ git config --global push.default simple\n</code></pre>"},{"location":"git/#bash-completion","title":"Bash Completion","text":"<p>Bash completion es una utilidad que permite a bash completar \u00f3rdenes y par\u00e1metros. Por defecto suele venir desactivada en Ubuntu y es necesario modificar el archivo <code>$HOME/.bashrc</code> para poder activarla. Simplemente hay que descomentar las l\u00edneas que lo activan,</p>"},{"location":"gitflow/","title":"Flujo de trabajo con Git (git flow)","text":"<p>Warning</p> <p>Esta secci\u00f3n se mantiene por motivos hist\u00f3ricos y de documentaci\u00f3n. En general, ya se considera una mala pr\u00e1ctica seguir este flujo de trabajo. Aunque hay muchos equipos que aun lo utilizan, por lo que viene bien conocerla, no deber\u00edas aplicarla en proyectos nuevos.</p>"},{"location":"gitflow/#la-importancia-de-la-organizacion-del-flujo-de-trabajo","title":"La importancia de la organizaci\u00f3n del flujo de trabajo","text":"<p>En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). </p> <p>Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n.</p> <p>En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por Vincent Driessen y que podemos ver en la figura siguiente.</p> <p></p>"},{"location":"gitflow/#las-ramas-principales","title":"Las ramas principales","text":"<p>En este esquema hay dos ramas principales con un tiempo de vida indefinido:</p> <ul> <li>main (origin/main): el c\u00f3digo apuntado por HEAD siempre contiene un estado listo para producci\u00f3n.</li> <li>develop (origin/develop): el c\u00f3digo apuntado por HEAD siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar rama de integraci\u00f3n. No es necesariamente estable.</li> </ul> <p>Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama main y una nueva versi\u00f3n es lanzada.</p>"},{"location":"gitflow/#las-ramas-auxiliares","title":"Las ramas auxiliares","text":"<p>Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan:</p> <ul> <li>Ramas de funcionalidad (feature branches)</li> <li>Ramas de versi\u00f3n (release branches)</li> <li>Ramas de parches (hotfix branches)</li> </ul>"},{"location":"gitflow/#feature-branches","title":"Feature branches","text":"<ul> <li>Pueden partir de: develop</li> <li>Deben fusionarse con: develop</li> <li>Convenici\u00f3n de nombres: feature-NUMissue-*.</li> </ul>"},{"location":"gitflow/#release-branches","title":"Release branches","text":"<ul> <li>Pueden partir de: develop</li> <li>Deben fusionarse con: develop y main</li> <li>Convenici\u00f3n de nombres: release-*</li> </ul>"},{"location":"gitflow/#hotfix-branches","title":"Hotfix branches","text":"<ul> <li>Pueden partir de: main</li> <li>Deben fusionarse con: develop y main</li> <li>Convenici\u00f3n de nombres: hotfix-*</li> </ul>"},{"location":"gitflow/#la-extension-flow-de-git","title":"La extensi\u00f3n flow de Git","text":"<p>Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es gitflow, que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo.</p>"},{"location":"gitflow/#instalacion","title":"Instalaci\u00f3n","text":"<p>Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en petervanderdoes/gitflow. En el wiki del repositorio est\u00e1n las instrucciones de instalaci\u00f3n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: <code>git flow</code>.</p>"},{"location":"gitflow/#uso","title":"Uso","text":"<p>Para cambiar a las ramas main y develop, seguiremos usando <code>git checkout</code>, pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes:</p>"},{"location":"gitflow/#-git-flow-init","title":"- git flow init:","text":"<p>Inicializa el espacio de trabajo. De forma autom\u00e1tica, crea las ramas que necesitamos y permite configurar el nombre de las mismas.</p> <pre><code>$ git flow init\nInitialized empty Git repository in ~/project/.git/\nNo branches exist yet. Base branches must be created now.\nBranch name for production releases: [main]\nBranch name for \"next release\" development: [develop]\n\nHow to name your supporting branch prefixes?\nFeature branches? [feature/]\nRelease branches? [release/]\nHotfix branches? [hotfix/]\nSupport branches? [support/]\nVersion tag prefix? []\n\n$ git branch\n* develop\n main\n</code></pre> <p>Podemos ver que por defecto (usando intro en vez de escribir nada) pone nombres por defecto a cada rama. Con <code>git branch</code> comprobamos que ramas existen y en cual nos encontramos.</p>"},{"location":"gitflow/#-git-flow-feature","title":"- git flow feature:","text":"<p>Permite crear y trabajar con ramas de funcionalidades.</p> <pre><code>$ git flow feature start feature_branch\n</code></pre> <p>As\u00ed creamos una rama 'feature/feature_branch' y nos mueve autom\u00e1ticamente a ella. En esta haremos los cambios que queramos en nuestro repositorio. Cuando queramos acabar de usar la rama, haremos un commit y la finalizaremos:</p> <pre><code>$ git flow feature stop feature_branch\n</code></pre> <p>Esto finaliza nuestra rama y la integra autom\u00e1ticamente a la rama develop. Si queremos seguir cambiando nuestro repositorio abriremos una nueva rama feature.</p>"},{"location":"gitflow/#-git-flow-release","title":"- git flow release:","text":"<p>Permite crear y trabajar con ramas de versiones. Cuando entendemos que despues de todas las funcionalidades (features, cambios en nuestro repositorio) nuestro trabajo esta listo para ser publicado, abriremos una rama release, que nacera de nuestra rama develop. </p> <pre><code>$ git flow release start 0.1.0\nSwitched to a new branch 'release/0.1.0'\n</code></pre> <p>Usaremos un tag para identificar de que release se trata. Ahora podemos hacer los cambios que estimemos oportuno para integrar todas las features que el repositorio ha sufrido hasta el momento. Tras hacer commit a todo el proceso, podemos cerrar la rama release.</p> <pre><code>$git flow release finish '0.1.0'\n</code></pre> <p>Esto la integrar\u00e1 de forma autom\u00e1tica con main (con esto finalizamos el proceso de 'subir a producci\u00f3n' nuestro codigo) y con la rama develop, para que las futuras features est\u00e9n al d\u00eda.</p>"},{"location":"gitflow/#-git-flow-hotfix","title":"- git flow hotfix:","text":"<p>Permite crear y trabajar con ramas de parches. Esto lo usaremos para hacer cambios rapidos que no puedan esperar a la proxima integracion de una release.</p> <pre><code>$ git flow hotfix start hotfix_branch\n</code></pre> <p>Tras hacer commit finalizamos la rama hotfix. Esta se fusionar\u00e1 con nuestra rama main y con nuestra rama develop para que esta tambi\u00e9n est\u00e9 al d\u00eda de los \u00faltimos cambios.</p> <pre><code>$ git flow hotfix finish hotfix_branch\n</code></pre>"},{"location":"github-avanzado/","title":"Github avanzado","text":"<p>Esta secci\u00f3n trata de c\u00f3mo colaborar con proyectos de terceros.</p>"},{"location":"github-avanzado/#clonar-un-repositorio","title":"Clonar un repositorio","text":"<p>Nos vamos a la web del proyecto en el que queremos colaborar. En este caso el proyecto se encuentra en https://github.com/sgomez/miniblog. Pulsamos en el bot\u00f3n de fork y eso crear\u00e1 una copia en nuestro perfil.</p> <p></p> <p>Una vez se termine de clonar el repositorio, nos encontraremos con el espacio de trabajo del mismo:</p> <ul> <li>En la parte superior informaci\u00f3n sobre los commits, ramas, etiquetas, etc.</li> <li>Justo debajo un explorador de archivos.</li> <li>En la parte derecha un selector para cambiar de contexto entre: explorador de c\u00f3digo, peticiones de colaboraci\u00f3n (pull request), wiki, configuraci\u00f3n, etc.</li> <li>Justo abajo a la derecha informaci\u00f3n sobre como clonar localmente o descargar un proyecto.</li> </ul> <p></p> <p>Github nos permite clonar localmente un proyecto por tres v\u00edas: HTTPS, SSH y Subversion. Seleccionamos SSH y copiamos el texto que despu\u00e9s a\u00f1adiremos a la orden <code>git clone</code> como en la primera l\u00ednea del siguiente grupo de \u00f3rdenes:</p> <pre><code>$ git clone git@github.com:miusuario/miniblog.git\n$ cd miniblog\n$ composer.phar install\n$ php console create-schema\n</code></pre> <p>Lo que hace el c\u00f3digo anterior es:</p> <ol> <li>Clona el repositorio localmente</li> <li>Entramos en la copia</li> <li>Instalamos las dependencias que la aplicaci\u00f3n tiene</li> <li>Arrancamos un servidor web para pruebas</li> </ol> <p>Y probamos que nuestra aplicaci\u00f3n funciona:</p> <pre><code>$ php -S localhost:9999 -t web/\n</code></pre> <p>Podemos usar dos direcciones para probarla:</p> <ul> <li>Frontend: <code>http://localhost:9999/index_dev.php</code></li> <li>Backend: <code>http://localhost:9999/index_dev.php/admin/</code> con usuario admin y contrase\u00f1a 1234.</li> </ul>"},{"location":"github-avanzado/#sincronizar-con-el-repositorio-original","title":"Sincronizar con el repositorio original","text":"<p>Cuando clonamos un repositorio de otro usuario hacemos una copia del original. Pero esa copia es igual al momento en el que hicimos la copia. Cuando el repositorio original cambie, que lo har\u00e1, nuestro repositorio no se actualizar\u00e1 solo. \u00a1Son dos repositorios diferentes! Necesitamos una manera de poder incorporar los cambios que vaya teniendo el repositorio original en el nuestro. Para eso crearemos una nueva rama remota. Por convenio, y como vimos anteriormente, ya existe una rama remota llamada origin que apunta al repositorio de donde clonamos el proyecto, en este caso apunta a nuestro fork en github:</p> <pre><code>$ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:miusuario/miniblog.git\n  Push  URL: git@github.com:miusuario/miniblog.git\n  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n    develop\n    main\n  Remote branches:\n    develop tracked\n    main  tracked\n  Local branch configured for 'git pull':\n    main merges with remote main\n  Local ref configured for 'git push':\n    main pushes to main (up to date)\n</code></pre> <p>Tambi\u00e9n por convenio, la rama remota que hace referencia al repositorio original se llama upstream y se crea de la siguiente manera:</p> <pre><code>$ git remote add upstream git@github.com:sgomez/miniblog.git\n$ git remote show upstream\n* remote upstream\n  Fetch URL: git@github.com:sgomez/miniblog.git\n  Push  URL: git@github.com:sgomez/miniblog.git\n  HEAD branch: main\n  Remote branches:\n    develop new (next fetch will store in remotes/upstream)\n    main  new (next fetch will store in remotes/upstream)\n  Local ref configured for 'git push':\n    main pushes to main (local out of date)\n</code></pre> <p>En este caso, la URI debe ser siempre la del proyecto original. Y ahora para incorporar actualizaciones, usaremos el merge en dos pasos:</p> <pre><code>$ git fetch upstream\n$ git merge upstream/main\n</code></pre> <p>Recordemos que fetch solo trae los cambios que existan en el repositorio remoto sin hacer ning\u00fan cambio en nuestro repositorio. Es la orden merge la que se encarga de que todo est\u00e9 sincronizado. En este caso decimos que queremos fusionar con la rama main que est\u00e1 en el repositorio upstream.</p>"},{"location":"github-avanzado/#creando-nuevas-funcionalidades","title":"Creando nuevas funcionalidades","text":"<p>Vamos a crear una nueva funcionalidad: vamos a a\u00f1adir una licencia de uso. Para ello preferentemente crearemos una nueva rama.</p> <pre><code>$ git checkout -b add-license\n$ echo \"LICENCIA MIT\" &gt; LICESE\n#\u00a0el error es intencionado\n$ git add LICESE\n$ git commit -m \"Archivo de licencia de uso\"\n</code></pre> <p>En principio habr\u00eda que probar que todo funciona bien y entonces integraremos en la rama main de nuestro repositorio y enviamos los cambios a Github:</p> <pre><code>$ git checkout main\n$ git merge add-license --no-ff\n$ git branch -d add-license\n# Borramos la rama que ya no nos sirve para nada\n$ git push --set-upstream origin add-license\n# Enviamos la rama a nuestro repositorio origin\n</code></pre> <p>Si volvemos a Github, veremos que nos avisa de que hemos subido una nueva rama y si queremos crear un pull request.</p> <p></p> <p>Pulsamos y entramos en la petici\u00f3n de Pull Request. Este es el momento para revisar cualquier error antes de enviar al due\u00f1o del repositorio. Como vemos hemos cometido uno, nombrando el fichero, si lo correguimos debemos hacer otro push para ir actualizando la rama. Cuando est\u00e9 lista volvemos aqu\u00ed y continuamos. Hay que dejar una descripci\u00f3n del cambio que vamos a hacer.</p> <p></p> <p>Una vez hemos terminado y nos aseguramos que todo est\u00e1 correcto, pulsamos Send pull request y le llegar\u00e1 nuestra petici\u00f3n al due\u00f1o del proyecto.</p> <p></p> <p>Sin embargo, para esta prueba, no vamos a cambiar el nombre del archivo y dejaremos el error como est\u00e1. As\u00ed de esta manera al administrador del proyecto le llegar\u00e1 el Pull Request y la lista de cambios. Ahora en principio, cabr\u00eda esperar que el administrador aprobara los cambios, pero podr\u00eda pasar que nos indicara que cambiemos algo. En ese caso solo habr\u00eda que modificar la rama y volverla a enviar.</p> <pre><code>$ git mv LICESE LICENSE\n$ git commit -m \"Fix: Nombre de archivo LICENSE\"\n$ git push\n</code></pre> <p>Ahora s\u00ed, el administrador puede aprobar la fusi\u00f3n y borrar la rama del repositorio. El panel de Github permite aceptar los cambios directamente o informa de como hacer una copia de la rama ofrecida por el usuario para hacer cambios, como puede verse en la siguiente imagen.</p> <p></p> <p>Una vez que se han aceptado los cambios, podemos borrar la rama y actualizar nuestro repositorio con los datos del remoto como hicimos antes. \u00bfPor qu\u00e9 actualizar desde el remoto y no desde nuetra rama add-license? Pues porque usualmente el administrador puede haber modificado los cambios que le hemos propuesto, o incluso una tercera persona. Recordemos el cariz colaborativo que tiene Github.</p> <pre><code>$ git checkout main\n$ git branch -d add-license\n# Esto borra la rama local\n$ git push origin --delete add-license\n# Esto borra la rama remota. Tambi\u00e9n puede hacerse desde la web.\n</code></pre>"},{"location":"github-avanzado/#todo-esto-es-algo-complicado","title":"Todo esto es algo complicado...","text":"<p>S\u00ed, lo es, al menos al principio. Git tiene una parte muy sencilla que es el uso del repositorio local (\u00f3rdenes tales como add, rm, mv y commit). El siguiente nivel de complejidad lo componen las \u00f3rdenes para trabajar con ramas y fusionarlas (checkout, branch, merge, rebase) y por \u00faltimo, las que trabajan con repositorios remotos (pull, push, fetch, remote). Adem\u00e1s hay otra serie de \u00f3rdenes para tener informaci\u00f3n (diff, log, status) o hacer operaciones de mantenimiento (fsck, gc). Lo importante para no perderse en Git, es seguir la siguiente m\u00e1xima:</p> <p>No avanzar al siguiente nivel de complejidad, hasta no haber entendido completamente el anterior.</p> <p>Muy poco sentido tiene ponernos a crear ramas en github si a\u00fan no entendemos c\u00f3mo se crean localmente y para que deben usarse. En la parte de referencias hay varios manuales en l\u00ednea, incluso tutoriales interactivos. Tambi\u00e9n hay mucha documentaci\u00f3n disponible en Github que suele venir muy bien explicada. En caso de que tengamos un problema que no sepamos resolver, una web muy buena es StackOverflow. Es una web de preguntas y respuestas para profesionales; es muy dif\u00edcil que se os plantee una duda que no haya sido ya preguntada y respondida en esa web. Eso s\u00ed, el ingl\u00e9s es imprescindible.</p>"},{"location":"github-avanzado/#ultimo-paso-documentacion","title":"\u00daltimo paso, documentaci\u00f3n.","text":"<p>Github permite crear documentaci\u00f3n. En primer lugar, generando un archivo llamado <code>README.md</code>. Tambi\u00e9n permite crear una web propia para el proyecto y, adem\u00e1s, una wiki. Para marcar el texto, se utiliza un lenguaje de marcado de texto denominado Markdown. En la siguiente web hay un tutorial interactivo: http://www.markdowntutorial.com/. Como en principio, no es necesario saber Markdown para poder trabajar con Git o con Github, no vamos a incidir m\u00e1s en este asunto.</p> <p>En el propio GitHub podemos encontrar algunas plantillas que nos sirvan de referencia.</p> <p>Algunos ejemplos:</p> <ul> <li>Plantilla b\u00e1sica</li> <li>Plantilla avanzada</li> </ul>"},{"location":"github-avanzado/#documentacion-del-curso","title":"Documentaci\u00f3n del curso","text":"<p>Esta documentaci\u00f3n est\u00e1 hecha en Markdown y pasada a HTML gracia a la herramienta mkdocs. La plantilla usada es Material for MkDocs.</p> <p>El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)</p>"},{"location":"github-flow/","title":"Flujo de trabajo en GitHub","text":""},{"location":"github-flow/#paso-0-abrir-una-incidencia-issue","title":"Paso 0. Abrir una incidencia (issue)","text":"<p>Habitualmente el trabajo puede partir a ra\u00edz de una reporte por parte de un miembro del equipo o de una persona externa. Para eso tenemos la secci\u00f3n Issues.</p> <p></p> <p>Una issue cuando se crea se compone de un t\u00edtulo y una descripci\u00f3n en Markdown. Si la persona es miembro del equipo, opcionalmente puede asignarle una serie de metadatos: etiquetas (labels), hitos (milestone), proyecto al que pertenece o responsables encargados de cerrar la incidencia.</p> <p></p> <p>Una vez creado, al mismo se le asignar\u00e1 un n\u00famero.</p> <p>Example</p> <p>Vamos a crear una incidencia llamada \"Crear archivo de autores\", donde indiquemos que vamos a crear un archivo <code>AUTHORS.md</code> con la lista de desarrolladores del proyecto.</p>"},{"location":"github-flow/#paso-1-crear-una-rama","title":"Paso 1. Crear una rama","text":"<p>Crearemos una rama cada vez que queramos implementar una nueva caracter\u00edstica al proyecto que estamos realizando. La misma puede estar provocada por una incidencia o no.</p> <p>Tip</p> <p>Es una buena costumbre crear en Issues el listado de casos de uso, requisitos, hostorias de usuario o tareas (como lo queramos llamar), para tener un registro del trabajo que llevamos y el que nos queda.</p> <p>El nombre de la rama puede ser el que creamos conveniente, pero hay que intentar ser coherente y usar siempre el mismo m\u00e9todo, sobre todo si trabajamos en equipo.</p> <p>Un m\u00e9todo puede ser el siguiente:</p> <pre><code>$ # tipo-n\u00famero/descripci\u00f3n\n$ git checkout -b feature-1/create-changelog\n$ git checkout -b hotfix-2/updated-database\n</code></pre> <p>En entornos de trabajo multiusuario se puede usar el siguiente:</p> <pre><code>$ # usuario/tipo-n\u00famero/descripci\u00f3n\n$ git checkout -b sgomez/feature-1/create-changelog\n$ git checkout -b sgomez/hotfix-2/updated-database\n</code></pre> <p>De esa manera, podemos seguir f\u00e1cilmente qui\u00e9n abri\u00f3 la rama, en qu\u00e9 consiste y a qu\u00e9 issues est\u00e1 conectada. Pero como decimos es m\u00e1s un convenio que una imposici\u00f3n, pudi\u00e9ndole poner el nombre que queramos.</p> <p>Vamos a crear la rama y los commits correspondientes y subir la rama con push al servidor.</p> <pre><code>$ git checkout -b sgomez/feature-1/create-changelog\n$ git add AUTHORS.md\n$ git commit -m \"A\u00f1adido fichero de autores\"\n</code></pre> <p>El archivo puede contener, por ejemplo, lo siguiente:</p> <pre><code># AUTHORS\n\n* Sergio G\u00f3mez &lt;sergio@uco.es&gt;\n</code></pre> <p>Hacemos push y obtenemos algo como esto:</p> <pre><code>$ git push\nfatal: The current branch sgomez/feature-1/create-changelog has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream origin sgomez/feature-1/create-changelog\n</code></pre> <p>Como la rama es nueva, git no sabe d\u00f3nde debe hacer push. Le indicamos que debe hacerla en origin y adem\u00e1s que guarde la vinculaci\u00f3n (equivalente al par\u00e1metro -u que vimos en el cap\u00edtulo anterior). Probamos de nuevo:</p> <pre><code>$ git push -u origin sgomez/feature-1/create-changelog\nEnumerating objects: 4, done.\nCounting objects: 100% (4/4), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 1.03 KiB | 1.03 MiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote:\nremote: Create a pull request for 'sgomez/feature-1/create-changelog' on GitHub by visiting:\nremote:      https://github.com/sgomez/taller-de-git/pull/new/sgomez/feature-1/create-changelog\nremote:\nTo github.com:sgomez/taller-de-git.git\n* [new branch]      sgomez/feature-1/create-changelog -&gt; sgomez/feature-1/create-changelog\nBranch 'sgomez/feature-1/create-changelog' set up to track remote branch 'sgomez/feature-1/create-changelog' from 'origin'.\n</code></pre> <p>Ahora la rama ya se ha subido y nos informa, adem\u00e1s, de que podemos crear un Pull Request (PR). Si vamos al enlace que nos aparece veremos lo siguiente:</p> <p></p> <p>Aqu\u00ed podemos informar de en qu\u00e9 consiste la rama que estamos enviando. Si ya tenemos una issue abierta, no es necesario repetir la misma informaci\u00f3n. Podemos hacer referencia con el siguiente texto:</p> <pre><code>Closes #1\n</code></pre> <p>Esto lo que le indica a GitHub que esta PR cierra el issues n\u00famero 1. Cuando se haga el merge de la rama, autom\u00e1ticamente se cerrar\u00e1 la incidencia.</p> <p>Lo hacemos y le damos a crear.</p> <p></p>"},{"location":"github-flow/#paso-2-crear-commits","title":"Paso 2. Crear commits","text":"<p>A partir de ahora podemos seguir creando commits en local y enviarlos hasta que terminemos de trabajar.</p> <p>Editamos el archivo AUTHORS.md .</p> <pre><code># AUTHORS\n\n* Sergio G\u00f3mez &lt;sergio@uco.es&gt;\n* John Doe\n</code></pre> <p>Y mandamos otro commit</p> <pre><code>$ git commit -am \"Actualizado AUTHORS.md\"\n$ git push\n</code></pre> <p>Si volvemos a la p\u00e1gina de PR, veremos que aparece el nuevo commit que acabamos de enviar.</p>"},{"location":"github-flow/#paso-3-discutir","title":"Paso 3. Discutir","text":"<p>GitHub permite que entre los desarrolladores se pueda abrir una discusi\u00f3n sobre el c\u00f3digo, de tal manera que el trabajo de crear la rama sea colaborativo. Se puede incluso pedir revisiones por parte de terceros y que esas revisiones sean obligatorias antes de aceptar los cambios.</p>"},{"location":"github-flow/#paso-4-desplegar","title":"Paso 4. Desplegar","text":"<p>Una vez que hemos terminado de crear la funci\u00f3n de la rama ya podemos incorporar los cambios a main. Este trabajo ya no es necesario hacerlo en local y GitHub nos proporciona 3 maneras de hacerlo:</p> <p></p>"},{"location":"github-flow/#crear-un-merge-commit","title":"Crear un merge commit","text":"<p>Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio:</p> <pre><code>$ git checkout main\n$ git merge --no-ff sgomez/feature-1/create-changelog\n$ git push\n</code></pre> <p>Es decir, el equivalente a hacer un merge entre nuestra rama y main.</p> <p>Info</p> <p>GitHub siempre desactiva el fast forward.</p>"},{"location":"github-flow/#crear-un-rebase-y-merge","title":"Crear un rebase y merge","text":"<p>Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio</p> <pre><code>$ git rebase main\n$ git checkout main\n$ git merge --no-ff sgomez/feature-1/create-changelog\n$ git push\n</code></pre> <p>Es decir, nos aseguramos de que nuestra rama est\u00e1 al final de main haciendo rebase, como vimos en el cap\u00edtulo de ramas, y posteriormente se hace el merge.</p>"},{"location":"github-flow/#crear-un-squash-commit-y-un-merge","title":"Crear un squash commit y un merge","text":"<p>Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio:</p> <pre><code>$ git checkout main\n$ git merge --squash sgomez/feature-1/create-changelog\n$ git push\n</code></pre> <p>Esta opci\u00f3n es algo especial. En vez de aplicar cada uno de los commits en la rama main, ya sea directamente (fast forward) o no, lo que hace es crear un solo commit con los cambios de todos los commits de la rama. El efecto final es como si en la rama solo hubiera producido un solo commit.</p> <p>Vamos a seleccionar este \u00faltimo (squash and merge) y le damos al bot\u00f3n para activarlo. Nos saldr\u00e1 una caja para que podamos crear una descripci\u00f3n del commit y le damos a confirmar.</p> <p></p> <p>Ya hemos terminado y nos aparecer\u00e1 una opci\u00f3n para borrar la rama, lo m\u00e1s recomendado para no tener ramas obsoletas.</p> <p>Las consecuencias de esta acci\u00f3n son las siguientes:</p> <ol> <li>El PR aparecer\u00e1 como estado merged y en la lista de PR como cerrado.</li> <li>El issue que abrimos se habr\u00e1 cerrado autom\u00e1ticamente.</li> <li>En el listado de commits aparecer\u00e1 solo uno con un enlace al PR (en vez de los dos commits que hicimos).</li> </ol>"},{"location":"github-flow/#paso-5-sincronizar","title":"Paso 5. Sincronizar","text":"<p>Hemos cambiado el repositorio en GitHub, pero nuestra rama main no contiene los mismos cambios que el de origin. As\u00ed que nos toca sincronizar y borrar la rama obsoleta:</p> <pre><code>$ git checkout main\n$ git pull --rebase --autostash\n$ git branch -D sgomez/feature-1/create-changelog\n</code></pre> <p>Info</p> <p>\u00bfPor qu\u00e9 squash and merge y no un merge o rebase? De nuevo depende de los gustos de cada equipo de desarrollo. Las cracter\u00edsticas de squash es que elimina (relativamente) rastros de errores intermedios mientras se implementaba la rama, deja menos commits en la rama main y nos enlace al PR donde se implementaron los cambios.</p> <p>Para algunas personas estas caracter\u00edsticas son unas ventajas, para otras no. Lo mejor es experimentar cada opci\u00f3n y cada uno decida como quiere trabajar.</p>"},{"location":"github-zenodo/","title":"Citar proyectos en GitHub","text":"<p>Extra\u00eddo de la gu\u00eda oficial de GitHub.</p> <p>A trav\u00e9s de una aplicaci\u00f3n de terceros (Zenodo, financiado por el CERN), es posible crear un DOI para uno de nuestros proyectos.</p> <p>Estos son los pasos</p>"},{"location":"github-zenodo/#paso-1-elegir-un-repositorio","title":"Paso 1. Elegir un repositorio","text":"<p>Este repositorio debe ser abierto (p\u00fablico), o de lo contrario Zenodo no podr\u00e1 acceder al mismo. Hay que recordar escoger una licencia para el proyecto. Esta web puede ayudarnos http://choosealicense.com/.</p>"},{"location":"github-zenodo/#paso-2-entrar-en-zenodo","title":"Paso 2. Entrar en Zenodo","text":"<p>Iremos a Zenodo y haremos login con GitHub. Lo \u00fanico que tenemos que hacer en esta parte es autorizar a Zenodo a conectar con nuestra cuenta de GitHub.</p> <p>Important</p> <p>Si deseas archivar un repositorio que pertenece a una organizaci\u00f3n en GitHub, deber\u00e1s asegurarte de que el administrador de la organizaci\u00f3n haya habilitado el acceso de terceros a la aplicaci\u00f3n Zenodo.</p>"},{"location":"github-zenodo/#paso-3-seleccionar-los-repositorios","title":"Paso 3. Seleccionar los repositorios","text":"<p>En este punto, hemos autorizado a Zenodo para configurar los permisos necesarios para permitir el archivado y la emisi\u00f3n del DOI. Para habilitar esta funcionalidad, simplemente haremo clic en el bot\u00f3n que est\u00e1 junto a cada uno de los repositorios que queremos archivar.</p> <p>Important</p> <p>Zenodo solo puede acceder a los repositorios p\u00fablicos, as\u00ed que debemos asegurarnos de que el repositorio que deseamos archivar sea p\u00fablico.</p>"},{"location":"github-zenodo/#paso-4-crear-una-nueva-release","title":"Paso 4. Crear una nueva release","text":"<p>Por defecto, Zenodo realiza un archivo de nuestro repositorio de GitHub cada vez que crea una nueva versi\u00f3n. Como a\u00fan no tenemos ninguna, tenemos que volver a la vista del repositorio principal y hacer clic en el elemento del encabezado de versiones (releases).</p>"},{"location":"github-zenodo/#paso-5-acunar-un-doi","title":"Paso 5. Acu\u00f1ar un DOI","text":"<p>Antes de que Zenodo pueda emitir un DOI para nuestro repositorio, deberemos proporcionar cierta informaci\u00f3n sobre el repositorio de GitHub que acaba de archivar.</p> <p>Una vez que estemos satisfechos con la descripci\u00f3n, heremos clic en el bot\u00f3n publicar.</p>"},{"location":"github-zenodo/#paso-6-publicar","title":"Paso 6. Publicar","text":"<p>De vuelta a nuestra p\u00e1gina de Zenodo, ahora deber\u00edamos ver el repositorio listado con una nueva insignia que muestra nuestro nuevo DOI.</p> <p>Tip</p> <p>Podemos colocar la insigna en nuestro proyecto. Para eso haremos clic en la imagen DOI gris y azul. Se abrir\u00e1 una ventana emergente y el texto que aparece como Markdown es el que deberemos copiar en nuestro archivo README.md.</p>"},{"location":"github/","title":"Github","text":"<p>Github es lo que se denomina una forja, un repositorio de proyectos que usan Git como sistema de control de versiones. Es la forja m\u00e1s popular, ya que alberga m\u00e1s de 10 millones de repositorios. Debe su popularidad a sus funcionalidades sociales, principalmente dos: la posibilidad de hacer forks de otros proyectos y la posibilidad de cooperar aportando c\u00f3digo para arreglar errores o mejorar el c\u00f3digo. Si bien, no es que fuera una novedad, s\u00ed lo es lo f\u00e1cil que resulta hacerlo. A ra\u00edz de este proyecto han surgido otros como Gitorius o Gitlab, pero Github sigue siendo el m\u00e1s popular y el que tiene mejores y mayores caracter\u00edsticas. algunas de estas son:</p> <ul> <li>Un wiki para documentar el proyecto, que usa MarkDown como lenguaje de marca.</li> <li>Un portal web para cada proyecto.</li> <li>Funcionalidades de redes sociales como followers.</li> <li>Gr\u00e1ficos estad\u00edsticos.</li> <li>Revisi\u00f3n de c\u00f3digo y comentarios.</li> <li>Sistemas de seguimiento de incidencias.</li> </ul> <p>Lo primero es entrar en el portal (https://github.com/) para crearnos una cuenta si no la tenemos a\u00fan.</p>"},{"location":"github/#tu-clave-publicaprivada","title":"Tu clave p\u00fablica/privada","text":"<p>Muchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio <code>$HOME/usuario/.ssh</code> no tiene un archivo id_dsa.pub o id_rsa.pub).</p> <p>Para crear una nueva clave usamos la siguiente orden:</p> <pre><code>$ ssh-keygen -t rsa -C \"Cuenta Thinstation\"\n</code></pre> <p>Warning</p> <p>Tu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de no compartir la clave privada con nadie. Por defecto la clave se crea como solo lectura.</p>"},{"location":"github/#configuracion","title":"Configuraci\u00f3n","text":"<p>Vamos a aprovechar para a\u00f1adir la clave RSA que generamos antes, para poder acceder desde git a los repositorios. Para ellos nos vamos al men\u00fa de configuraci\u00f3n de usuario (Settings)</p> <p></p> <p>Nos vamos al men\u00fa 'SSH and GPG Keys' y a\u00f1adimos una nueva clave. En Title indicamos una descripci\u00f3n que nos ayude a saber de d\u00f3nde procede la clave y en key volcamos el contenido del archivo <code>~/.ssh/id_rsa.pub</code>. Y guardamos la clave.</p> <p></p> <p>Con esto ya tendriamos todo nuestro entorno para poder empezar a trabajar desde nuestro equipo.</p>"},{"location":"github/#clientes-graficos-para-github","title":"Clientes gr\u00e1ficos para GitHub","text":"<p>Adem\u00e1s, para Github existe un cliente propio tanto para Windows como para MacOSX:</p> <ul> <li> <p>Cliente Windows: http://windows.github.com/</p> </li> <li> <p>Cliente MacOSX: http://mac.github.com/</p> </li> </ul> <p>Para Linux no hay cliente propio, pero s\u00ed hay plugin para la mayor\u00eda de editores de texto como atom, netbeans, eclipe o los editores de jetbrains.</p> <p>De todas maneras, estos clientes solo tienen el fin de facilitar el uso de Github, pero no son necesarios para usarlo. Es perfectamente v\u00e1lido usar el cliente de consola de Git o cualquier otro cliente gen\u00e9rico para Git. Uno de los m\u00e1s usados actualmente es GitKraken.</p>"},{"location":"github/#crear-un-repositorio","title":"Crear un repositorio","text":"<p>Vamos a crear un repositorio donde guardar nuestro proyecto. Para ello pulsamos el signo <code>+</code> que hay en la barra superior y seleccionamos <code>New repository</code>.</p> <p>Ahora tenemos que designar un nombre para nuestro repositorio, por ejemplo: 'taller-de-git'.</p> <p></p> <p>Nada m\u00e1s crear el repositorio nos saldr\u00e1 una pantalla con instrucciones precisas de como proceder a continuaci\u00f3n.</p> <p>B\u00e1sicamente podemos partir de tres situaciones:</p> <ol> <li>Todav\u00eda no hemos creado ning\u00fan repositorio en nuestro equipo.</li> <li>Ya tenemos un repositorio creado y queremos sincronizarlo con Github.</li> <li>Queremos importar un repositorio de otro sistema de control de versiones distinto.</li> </ol> <p></p> <p>Nuestra situaci\u00f3n es la segunda, as\u00ed que nos aseguramos de que hemos elegido SSH como protocolo. A continuaci\u00f3n pulsamos el icono del portapapeles y ejecutamos las dos ordenes que nos indica la web en nuestro terminal.</p> <pre><code>$ git remote add origin git@github.com:sgomez/taller-de-git.git\n$ git push -u origin main\nCounting objects: 33, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (24/24), done.\nWriting objects: 100% (33/33), 3.35 KiB | 1.12 MiB/s, done.\nTotal 33 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo github.com:sgomez/taller-de-git.git\n * [new branch]      main -&gt; main\nBranch main set up to track remote branch main from origin by rebasing.\n</code></pre> <p>Si recargamos la p\u00e1gina veremos que ya aparece nuestro proyecto.</p> <p></p>"},{"location":"github/#crear-una-clave-ssh","title":"Crear una clave SSH","text":"<p>Muchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio <code>$HOME/usuario/.ssh</code> no tiene un archivo id_dsa.pub o id_rsa.pub).</p> <p>Para crear una nueva clave usamos la siguiente orden:</p> <pre><code>ssh-keygen -t ed25519 -C \"Mi ordenador personal\"\n</code></pre> <p>Warning</p> <p>Ejecuta la orden anterior solo si no tenias ya una clave creada.</p> <p>Tu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de no compartir la clave privada con nadie. Por defecto la clave se crea como solo lectura.</p> <p>En la web de Github tienes una documetaci\u00f3n m\u00e1s detallada.</p>"},{"location":"github/#clonar-un-repositorio","title":"Clonar un repositorio","text":"<p>Una vez que ya tengamos sincronizado el repositorio contra Github, eventualmente vamos a querer descargarlo en otro de nuestros ordenadores para poder trabajar en \u00e9l. Esta acci\u00f3n se denomina clonar y para ello usaremos la orden <code>git clone</code>.</p> <p>En la p\u00e1gina principal de nuestro proyecto podemos ver un bot\u00f3n que indica <code>Clone or download</code>. Si la pulsamos nos da, de nuevo, la opci\u00f3n de elegir entre clonar con ssh o https.</p> <p>Para clonar nuestro repositorio y poder trabajar con \u00e9l todo lo que debemos hacer es lo siguiente:</p> <pre><code>$ git clone git@github.com:sgomez/taller-de-git.git\n$ cd taller-de-git\n</code></pre>"},{"location":"github/#ramas-remotas","title":"Ramas remotas","text":"<p>Si ahora vemos el estado de nuestro proyecto veremos algo similar a esto:</p> <pre><code>$ git hist --all\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -&gt; main, origin/main) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Aparece que hay una nueva rama llamada <code>origin/main</code>. Esta rama indica el estado de sincronizaci\u00f3n de nuestro repositorio con un repositorio remoto llamado origin. En este caso el de Github.</p> <p>Info</p> <p>Por norma se llama autom\u00e1ticamente origin al primer repositorio con el que sincronizamos nuestro repositorio.</p> <p>Podemos ver la configuraci\u00f3n de este repositorio remoto con la orden <code>git remote</code>:</p> <pre><code>$ git remote show origin\n* remote origin\n  Fetch URL: git@github.com:sgomez/taller-de-git.git\n  Push  URL: git@github.com:sgomez/taller-de-git.git\n  HEAD branch: main\n  Remote branch:\n    main tracked\n  Local ref configured for 'git push':\n    main pushes to main (up to date)\n</code></pre> <p>De la respuesta tenemos que fijarnos en las l\u00edneas que indican fetch y push puesto que son las acciones de sincronizaci\u00f3n de nuestro repositorio con el remoto. Mientras que fetch se encarga de traer los cambios desde el repositorio remoto al nuestro, push los env\u00eda.</p>"},{"location":"github/#enviando-actualizaciones","title":"Enviando actualizaciones","text":"<p>Vamos a a\u00f1adir una licencia a nuestra aplicaci\u00f3n. Creamos un fichero LICENSE con el siguiente contenido:</p> <pre><code>MIT License\n\nCopyright (c) [year] [fullname]\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre> <p>Y a\u00f1adidos y confirmamos los cambios:</p> <pre><code>$ git add LICENSE\n$ git commit -m \"A\u00f1adida licencia\"\n[main 3f5cb1c] A\u00f1adida licencia\n 1 file changed, 21 insertions(+)\n create mode 100644 LICENSE\n$ git hist --all\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -&gt; main) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (origin/main) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Viendo la historia podemos ver como nuestro main no est\u00e1 en el mismo punto que <code>origin/main</code>. Si vamos a la web de Github veremos que <code>LICENSE</code> no aparece a\u00fan. As\u00ed que vamos a enviar los cambios con la primera de las acciones que vimos <code>git push</code>:</p> <pre><code>$ git push -u origin main\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 941 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo git@github.com:sgomez/taller-de-git.git\n   2eab8ca..3f5cb1c  main -&gt; main\nBranch main set up to track remote branch main from origin.\n</code></pre> <p>Info</p> <p>La orden <code>git push</code> necesita dos par\u00e1metros para funcionar: el repositorio y la rama destino. As\u00ed que realmente lo que ten\u00edamos que haber escrito es:</p> <pre><code>$ git push origin main\n</code></pre> <p>Para ahorrar tiempo escribiendo git nos deja vincular nuestra rama local con una rama remota, de tal manera que no tengamos que estar siempre indic\u00e1ndolo. Eso es posible con el par\u00e1metro <code>--set-upstream</code> o <code>-u</code> en forma abreviada.</p> <pre><code>$ git push -u origin main\n</code></pre> <p>Si repasas las \u00f3rdenes que te indic\u00f3 Github que ejecutaras ver\u00e1s que el par\u00e1metro <code>-u</code> estaba presente y por eso no ha sido necesario indicar ning\u00fan par\u00e1metro al hacer push.</p>"},{"location":"github/#recibiendo-actualizaciones","title":"Recibiendo actualizaciones","text":"<p>Si trabajamos con m\u00e1s personas, o trabajamos desde dos ordenadores distintos, nos encontraremos con que nuestro repositorio local es m\u00e1s antiguo que el remoto. Necesitamos descargar los cambios para poder incorporarlos a nuestro directorio de trabajo.</p> <p>Para la prueba, Github nos permite editar archivos directamente desde la web. Pulsamos sobre el archivo <code>README.md</code>. En la vista del archivo, veremos que aparece el icono de un l\u00e1piz. Esto nos permite editar el archivo.</p> <p></p> <p>Info</p> <p>Los archivos con extensi\u00f3n <code>.md</code> est\u00e1n en un formato denominado MarkDown. Se trata de un lenguaje de marca que nos permite escribir texto enriquecido de manera muy sencilla.</p> <p>Dispones de un tutorial aqu\u00ed: https://www.markdowntutorial.com/</p> <p>Modificamos el archivo como queramos, por ejemplo, a\u00f1adiendo nuestro nombre:</p> <pre><code># Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT\n\nDesarrollado por Sergio G\u00f3mez.\n</code></pre> <p></p> <p>El cambio quedar\u00e1 incorporado al repositorio de Github, pero no al nuestro. Necesitamos traer la informaci\u00f3n desde el servidor remoto. La orden asociada es <code>git fetch</code>:</p> <pre><code>$ git fetch\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (origin/main) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -&gt; main) [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Ahora vemos el caso contrario, tenemos que <code>origin/main</code> est\u00e1 por delante que <code>HEAD</code> y que la rama <code>main</code> local.</p> <p>Ahora necesitamos incorporar los cambios de la rama remota en la local. La forma de hacerlo lo vimos en el cap\u00edtulo anterior usando <code>git merge</code> o <code>git rebase</code>.</p> <p>Habitualmente se usa <code>git merge</code>:</p> <pre><code>$ git merge origin/main\nUpdating 3f5cb1c..cbaf831\nFast-forward\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n$ git hist --all\n* cbaf831 2013-06-16 | Actualizado README.md (HEAD -&gt; main, origin/main) [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Como las operaciones de traer cambios (<code>git fetch</code>) y de mezclar ramas (<code>git merge</code> o <code>git rebase</code>) est\u00e1n muy asociadas, git nos ofrece una posibilidad para ahorrar pasos que es la orden <code>git pull</code> que realiza las dos acciones simult\u00e1neamente.</p> <p>Para probar, vamos a editar de nuevo el archivo README.md y a\u00f1adimos algo m\u00e1s:</p> <pre><code># Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT del Aula de Software Libre.\n\nDesarrollado por Sergio G\u00f3mez.\n</code></pre> <p>Como mensaje del commit: 'Indicado que se realiza en el ASL'.</p> <p>Y ahora probamos a actualizar con <code>git pull</code>:</p> <pre><code>$ git pull\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom github.com:sgomez/taller-de-git\n   cbaf831..d8922e4  main     -&gt; origin/main\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded main to d8922e4ffa4f87553b03e77df6196b7e496bfec4.\n$ git hist --all\n* d8922e4 2013-06-16 | Indicado que se realiza en el ASL (HEAD -&gt; main, origin/main) [Sergio G\u00f3mez]\n* cbaf831 2013-06-16 | Actualizado README.md [Sergio G\u00f3mez]\n* 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez]\n* 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Vemos que los cambios se han incorporado y que las ramas remota y local de main est\u00e1n sincronizadas.</p>"},{"location":"github/#problemas-de-sincronizacion","title":"Problemas de sincronizaci\u00f3n","text":""},{"location":"github/#no-puedo-hacer-push","title":"No puedo hacer push","text":"<p>Al intentar subir cambios nos podemos encontrar un mensaje como este:</p> <pre><code>$ git push\ngit push\nTo git@github.com:sgomez/taller-de-git.git\n ! [rejected]        main -&gt; main (fetch first)\nerror: failed to push some refs to 'git@github.com:sgomez/taller-de-git.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n</code></pre> <p>La causa es que el repositorio remoto tambi\u00e9n se ha actualizado y nosotros a\u00fan no hemos recibido esos cambios. Es decir, ambos repositorios se han actualizado y el remoto tiene preferencia. Hay un conflicto en ciernes y se debe resolver localmente antes de continuar.</p> <p>Vamos a provocar una situaci\u00f3n donde podamos ver esto en acci\u00f3n. Vamos a modificar el archivo <code>README.md</code> tanto en local como en remoto a trav\u00e9s del interfaz web.</p> <p>En el web vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera.</p> <pre><code>Curso de GIT, 2020\n</code></pre> <p>En local vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera.</p> <pre><code>Curso de GIT, febrero\n</code></pre> <p>Question</p> <p>Haz el commit para guardar el cambio en local.</p> Respuesta al ejercicio anterior <p>A\u00f1adimos el fichero actualizado:</p> <pre><code>$ git commit -am \"A\u00f1adido el mes al README\"\n[main 1e8c0b7] A\u00f1adido el mes al README\n1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre> <p>La forma de proceder en este caso es hacer un <code>git fetch</code> y un <code>git rebase</code>. Si hay conflictos deber\u00e1n resolverse. Cuando est\u00e9 todo solucionado ya podremos hacer <code>git push</code>.</p> <p>Info</p> <p>Por defecto <code>git pull</code> lo que hace es un <code>git merge</code>, si queremos hacer <code>git rebase</code> deberemos especificarlos con el par\u00e1metro <code>-r</code>:</p> <pre><code>$ git pull --rebase\n</code></pre> <p>Vamos a hacer el pull con rebase y ver qu\u00e9 sucede.</p> <pre><code>$ git pull --rebase\nFirst, rewinding head to replay your work on top of it...\nApplying: A\u00f1adido el mes al README\nUsing index info to reconstruct a base tree...\nM   README.md\nFalling back to patching base and 3-way merge...\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nerror: Failed to merge in the changes.\nPatch failed at 0001 A\u00f1adido el mes al README\nhint: Use 'git am --show-current-patch' to see the failed patch\n\nResolve all conflicts manually, mark them as resolved with\n\"git add/rm &lt;conflicted_files&gt;\", then run \"git rebase --continue\".\nYou can instead skip this commit: run \"git rebase --skip\".\nTo abort and get back to the state before \"git rebase\", run \"git rebase --abort\".\n</code></pre> <p>Evidentemente hay un conflicto porque hemos tocado el mismo archivo. Se deja como ejercicio resolverlo.</p> Respuesta al ejercicio anterior <p>El contenido del fichero final podr\u00eda ser:</p> <pre><code>Curso de GIT, febrero, 2020\n</code></pre> <p>A continuaci\u00f3n confirmamos los cambios y los enviamos al servidor</p> <pre><code>$ git add README.md\n$ git rebase --continue\n$ git push\n</code></pre> <p>Warning</p> <p>\u00bfPor qu\u00e9 hemos hecho rebase en main si a lo largo del curso hemos dicho que no se debe cambiar la linea principal?</p> <p>B\u00e1sicamente hemos dicho que lo que no debemos hacer es modificar la l\u00ednea temporal compartida. En este caso nuestros cambios en main solo estaban en nuestro repositorio, porque al fallar el env\u00edo nadie m\u00e1s ha visto nuestras actualizaciones. Al hacer rebase estamos deshaciendo nuestros cambios, bajarnos la \u00faltima actualizaci\u00f3n compartida de main y volvi\u00e9ndolos a aplicar. Con lo que realmente la historia compartida no se ha modificado.</p> <p>Este es un problema que debemos evitar en la medida de lo posible. La menor cantidad de gente posible debe tener acceso de escritura en main y las actualizaciones de dicha rama deben hacerse a trav\u00e9s de ramas secundarias y haciendo merge en main como hemos visto en el cap\u00edtulo de ramas.</p>"},{"location":"github/#no-puedo-hacer-pull","title":"No puedo hacer pull","text":"<p>Al intentar descargar cambios nos podemos encontrar un mensaje como este:</p> <pre><code>$ git pull\nerror: Cannot pull with rebase: You have unstaged changes.\n</code></pre> <p>O como este:</p> <pre><code>$ git pull\nerror: Cannot pull with rebase: Your index contains uncommitted changes.\n</code></pre> <p>B\u00e1sicamente lo que ocurre es que tenemos cambios sin confirmar en nuestro espacio de trabajo. Una opci\u00f3n es confirmar (commit) y entonces proceder como el caso anterior.</p> <p>Pero puede ocurrir que a\u00fan estemos trabajando todav\u00eda y no nos interese confirmar los cambios, solo queremos sincronizar y seguir trabajando. Para casos como estos git ofrece una pila para guardar cambios temporalmente. Esta pila se llama stash y nos permite restaurar el espacio de trabajo al \u00faltimo commit.</p> <p>De nuevo vamos a modificar nuestro proyecto para ver esta situaci\u00f3n en acci\u00f3n.</p> <p>Example</p> <p>En remoto borra el a\u00f1o de la fecha y en local borra el mes. Pero esta vez no hagas commit en local. El archivo solo debe quedar modificado.</p> <p>La forma de proceder es la siguiente:</p> <pre><code>$ git stash save # Guardamos los cambios en la pila\n$ git pull # Sincronizamos con el repositorio remoto, -r para hacer rebase puede ser requerido\n$ git stash pop # Sacamos los cambios de la pila\n</code></pre> <p>Info</p> <p>Como ocurre habitualmente, git nos proporciona una forma de hacer todos estos pasos de una sola vez. Para ello tenemos que ejecutar lo siguiente:</p> <pre><code>$ git pull --autostash\n</code></pre> <p>En general no es mala idea ejecutar lo siguiente si somos conscientes, adem\u00e1s, de que tenemos varios cambios sin sincronizar:</p> <pre><code>$ git pull --autostash --rebase\n</code></pre> <p>Podr\u00eda darse el caso de que al sacar los cambios de la pila hubiera alg\u00fan conflicto. En ese caso actuamos como con el caso de merge o rebase.</p> <p>De nuevo este tipo de problemas no deben suceder si nos acostumbramos a trabajar en ramas.</p>"},{"location":"introduccion/","title":"Introducci\u00f3n a git","text":"<p>Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos.</p> <p></p> <p></p>"},{"location":"introduccion/#los-tres-estados","title":"Los tres estados","text":"<p>Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n.</p> <p>Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area).</p> <p></p>"},{"location":"introduccion/#flujos-de-trabajo-distribuidos-con-git","title":"Flujos de trabajo distribuidos con git","text":"<p>Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git.</p>"},{"location":"introduccion/#flujo-de-trabajo-centralizado","title":"Flujo de trabajo centralizado","text":"<p>Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero</p> <p></p>"},{"location":"introduccion/#flujo-de-trabajo-del-gestor-de-integraciones","title":"Flujo de trabajo del Gestor-de-Integraciones","text":"<p>Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto.</p> <p></p> <p>Info</p> <p>Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante.</p>"},{"location":"introduccion/#flujo-de-trabajo-con-dictador-y-tenientes","title":"Flujo de trabajo con Dictador y Tenientes","text":"<p>Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.</p> <p></p>"},{"location":"ramas/","title":"Ramas","text":""},{"location":"ramas/#administracion-de-ramas","title":"Administraci\u00f3n de ramas","text":""},{"location":"ramas/#crear-una-nueva-rama","title":"Crear una nueva rama","text":"<p>Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. Aunque la orden para manejar ramas es <code>git branch</code> podemos usar tambi\u00e9n <code>git checkout</code>.</p> <p>Vamos a crear una nueva rama:</p> <pre><code>git branch hola\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola</code></pre> <p>Info</p> <p>Si usamos <code>git branch</code> sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas disponibles.</p> <p>La orden anterior no devuelve ning\u00fan resultado y tampoco nos cambia de rama, para eso debemos usar checkout:</p> <pre><code>$ git checkout hola\nSwitched to branch 'hola'\n</code></pre> <p>Tip</p> <p>Hay una forma m\u00e1s rapida de hacer ambas acciones en un solo paso. Con el par\u00e1metro <code>-b</code> de <code>git checkout</code> podemos cambiarnos a una rama que, si no existe, se crea instant\u00e1neamente.</p> <pre><code>$ git checkout -b hola\nSwitched to a new branch 'hola'\n</code></pre>"},{"location":"ramas/#modificaciones-en-la-rama-secundaria","title":"Modificaciones en la rama secundaria","text":"<p>A\u00f1adimos un nuevo archivo en el directorio <code>lib</code> llamado <code>HolaMundo.php</code>:</p> <pre><code>&lt;?php\n\nclass HolaMundo\n{\n   private $nombre;\n\n   function __construct($nombre)\n   {\n      $this-&gt;nombre = $nombre;\n   }\n\n   function __toString()\n   {\n      return sprintf (\"Hola, %s.\\n\", $this-&gt;nombre);\n   }\n}\n</code></pre> <p>Y modificamos <code>hola.php</code>:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\n// El nombre por defecto es Mundo\nrequire('HolaMundo.php');\n\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\nprint new HolaMundo($nombre);\n</code></pre> <p>Podr\u00edamos confirmar los cambios todos de golpe, pero lo haremos de uno en uno, con su comentario.</p> <pre><code>$ git add lib/HolaMundo.php\n$ git commit -m \"A\u00f1adida la clase HolaMundo\"\n[hola 6932156] A\u00f1adida la clase HolaMundo\n 1 file changed, 16 insertions(+)\n create mode 100644 lib/HolaMundo.php\n$ git add lib/hola.php\n$ git commit -m \"hola usa la clase HolaMundo\"\n[hola 9862f33] hola usa la clase HolaMundo\n 1 file changed, 3 insertions(+), 1 deletion(-)\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"</code></pre> <p>Y ahora con la orden <code>git checkout</code> podemos movernos entre ramas:</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n$ git checkout hola\nSwitched to branch 'hola'\n</code></pre>"},{"location":"ramas/#modificaciones-en-la-rama-main","title":"Modificaciones en la rama main","text":"<p>Podemos volver y a\u00f1adir un nuevo archivo a la rama principal:</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n</code></pre> <p>Creamos un archivo llamado <code>README.md</code> en la ra\u00edz de nuestro proyecto con el siguiente contenido:</p> <pre><code># Curso de GIT\n\nEste proyecto contiene el curso de introducci\u00f3n a GIT\n</code></pre> <p>Y lo a\u00f1adimos a nuestro repositorio en la rama en la que estamos:</p> <pre><code>$ git add README.md\n$ git commit -m \"A\u00f1adido README.md\"\n[main c3e65d0] A\u00f1adido README.md\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n* c3e65d0 2013-06-16 | A\u00f1adido README.md (HEAD, main) [Sergio G\u00f3mez]\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Y vemos como <code>git hist</code> muestra la bifurcaci\u00f3n en nuestro c\u00f3digo.</p> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   commit id: \"c3e65d0\"</code></pre>"},{"location":"ramas/#fusion-de-ramas-y-resolucion-de-conflictos","title":"Fusi\u00f3n de ramas y resoluci\u00f3n de conflictos","text":""},{"location":"ramas/#mezclar-ramas","title":"Mezclar ramas","text":"<p>Podemos incorporar los cambios de una rama a otra con la orden <code>git merge</code></p> <pre><code>$ git checkout hola\nSwitched to branch 'hola'\n$ git merge main\nMerge made by the 'recursive' strategy.\n README.md | 3 +++\n 1 file changed, 3 insertions(+)\n create mode 100644 README.md\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (HEAD, hola) [Sergio G\u00f3mez]\n|\\\n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| |\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   commit id: \"c3e65d0\"\n   checkout hola\n   merge main id: \"9c6ac06\"</code></pre> <p>De esa forma se puede trabajar en una rama secundaria incorporando los cambios de la rama principal o de otra rama.</p>"},{"location":"ramas/#resolver-conflictos","title":"Resolver conflictos","text":"<p>Un conflicto es cuando se produce una fusi\u00f3n que Git no es capaz de resolver. Vamos a modificar la rama main para crear uno con la rama hola.</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n</code></pre> <p>Modificamos nuestro archivo hola.php de nuevo:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nprint \"Introduce tu nombre:\";\n$nombre = trim(fgets(STDIN));\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y guardamos los cambios:</p> <pre><code>$ git add lib/hola.php\n$ git commit -m \"Programa interactivo\"\n[main 9c85275] Programa interactivo\n 1 file changed, 2 insertions(+), 2 deletions(-)\n$ git hist --all\n*   9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (hola) [Sergio G\u00f3mez]\n|\\\n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| | * 9c85275 2013-06-16 | Programa interactivo (HEAD, main) [Sergio G\u00f3mez]\n| |/\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   commit id: \"c3e65d0\"\n   checkout hola\n   merge main id: \"9c6ac06\"\n   checkout main\n   commit id: \"9c85275\"</code></pre> <p>Volvemos a la rama hola y fusionamos:</p> <pre><code>$ git checkout hola\nSwitched to branch 'hola'\n$ git merge main\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>Si editamos nuestro archivo <code>lib/hola.php</code> obtendremos algo similar a esto:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n// El nombre por defecto es Mundo\nrequire('HolaMundo.php');\n\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\nprint new HolaMundo($nombre);\n=======\nprint \"Introduce tu nombre:\";\n$nombre = trim(fgets(STDIN));\n@print \"Hola, {$nombre}\\n\";\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; main\n</code></pre> <p>La primera parte marca el c\u00f3digo que estaba en la rama donde trabaj\u00e1bamos (HEAD) y la parte final el c\u00f3digo de donde fusion\u00e1bamos. Resolvemos el conflicto, dejando el archivo como sigue:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nrequire('HolaMundo.php');\n\nprint \"Introduce tu nombre:\";\n$nombre = trim(fgets(STDIN));\nprint new HolaMundo($nombre);\n</code></pre> <p>Y resolvemos el conflicto confirmando los cambios:</p> <pre><code>$ git add lib/hola.php\n$ git commit -m \"Solucionado el conflicto al fusionar con la rama main\"\n[hola a36af04] Solucionado el conflicto al fusionar con la rama main\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   commit id: \"c3e65d0\"\n   checkout hola\n   merge main id: \"9c6ac06\"\n   checkout main\n   commit id: \"9c85275\"\n   checkout hola\n   merge main id: \"a36af04\"</code></pre>"},{"location":"ramas/#rebasing-vs-merging","title":"Rebasing vs Merging","text":"<p>Rebasing es otra t\u00e9cnica para fusionar distinta a merge y usa la orden <code>git rebase</code>. Vamos a dejar nuestro proyecto como estaba antes del fusionado. Para ello necesitamos anotar el hash anterior al de la acci\u00f3n de merge. El que tiene la anotaci\u00f3n \"hola usa la clase HolaMundo\".</p> <p>Para ello podemos usar la orden <code>git reset</code> que nos permite mover HEAD donde queramos.</p> <pre><code>$ git checkout hola\nSwitched to branch 'hola'\n$ git hist\n*   a36af04 2013-06-16 | Solucionado el conflicto al fusionar con la rama main (HEAD, hola) [Sergio G\u00f3mez]\n|\\\n| * 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* |   9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola [Sergio G\u00f3mez]\n|\\ \\\n| |/\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez]\n* | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n$ git reset --hard 9862f33\nHEAD is now at 9862f33 hola usa la clase HolaMundo\n</code></pre> <p>Y nuestro estado ser\u00e1:</p> <pre><code>$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD, hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n| * 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n| * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n|/\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   commit id: \"c3e65d0\"\n   commit id: \"9c85275\"</code></pre> <p>Hemos desecho todos los merge y nuestro \u00e1rbol est\u00e1 \"limpio\". Vamos a probar ahora a hacer un rebase. Continuamos en la rama <code>hola</code> y ejecutamos lo siguiente:</p> <pre><code>$ git rebase main\nFirst, rewinding head to replay your work on top of it...\nApplying: A\u00f1adida la clase HolaMundo\nApplying: hola usa la clase HolaMundo\nUsing index info to reconstruct a base tree...\nM   lib/hola.php\nFalling back to patching base and 3-way merge...\nAuto-merging lib/hola.php\nCONFLICT (content): Merge conflict in lib/hola.php\nerror: Failed to merge in the changes.\nPatch failed at 0002 hola usa la clase HolaMundo\nThe copy of the patch that failed is found in: .git/rebase-apply/patch\n\nWhen you have resolved this problem, run \"git rebase --continue\".\nIf you prefer to skip this patch, run \"git rebase --skip\" instead.\nTo check out the original branch and stop rebasing, run \"git rebase --abort\".\n</code></pre> <p>El conflicto, por supuesto, se sigue dando. Resolvemos guardando el archivo <code>hola.php</code> como en los casos anteriores:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nrequire('HolaMundo.php');\n\nprint \"Introduce tu nombre:\";\n$nombre = trim(fgets(STDIN));\nprint new HolaMundo($nombre);\n</code></pre> <p>A\u00f1adimos los cambios en staging y en esta ocasi\u00f3n, y tal como nos indicaba en el mensaje anterior, no tenemos que hacer <code>git commit</code> sino continuar con el rebase:</p> <pre><code>$ git add lib/hola.php\n$ git status\nrebase in progress; onto 269eaca\nYou are currently rebasing branch 'hola' on '269eaca'.\n  (all conflicts fixed: run \"git rebase --continue\")\n\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n    modified:   lib/hola.php\n$ git rebase --continue\nApplying: hola usa la clase HolaMundo\n</code></pre> <p>Y ahora vemos que nuestro \u00e1rbol tiene un aspecto distinto, mucho m\u00e1s limpio:</p> <pre><code>$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -&gt; hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   commit id: \"c3e65d0\"\n   commit id: \"9c85275\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"</code></pre> <p>Lo que hace rebase es volver a aplicar todos los cambios a la rama m\u00e1ster, desde su nodo m\u00e1s reciente. Eso significa que se modifica el orden o la historia de creaci\u00f3n de los cambios. Por eso rebase no debe usarse si el orden es importante o si la rama es compartida.</p>"},{"location":"ramas/#mezclando-con-la-rama-main","title":"Mezclando con la rama main","text":"<p>Ya hemos terminado de implementar los cambios en nuestra rama secundaria y es hora de llevar los cambios a la rama principal. Usamos <code>git merge</code> para hacer una fusi\u00f3n normal:</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n$ git merge hola\nUpdating c3e65d0..491f1d2\nFast-forward\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n $ git hist --all\n * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -&gt; main, hola) [Sergio G\u00f3mez]\n * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n * 9c85275 2013-06-16 | Programa interactivo [Sergio G\u00f3mez]\n * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Vemos que indica que el tipo de fusi\u00f3n es fast-forward. Este tipo de fusi\u00f3n tiene el problema que no deja rastro de la fusi\u00f3n, por eso suele ser recomendable usar el par\u00e1metro <code>--no-ff</code> para que quede constancia siempre de que se ha fusionado una rama con otra.</p> <p>Vamos a volver a probar ahora sin hacer fast-forward. Reseteamos main al estado \"Programa interactivo\".</p> <pre><code>$ git reset --hard 9c85275\n$ git hist --all\n* 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -&gt; hola) [Sergio G\u00f3mez]\n* 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <p>Vemos que estamos como en el final de la secci\u00f3n anterior, as\u00ed que ahora mezclamos:</p> <pre><code>$ git merge -m \"Aplicando los cambios de la rama hola\" --no-ff hola\nMerge made by the 'recursive' strategy.\n lib/HolaMundo.php | 16 ++++++++++++++++\n lib/hola.php      |  4 +++-\n 2 files changed, 19 insertions(+), 1 deletion(-)\n create mode 100644 lib/HolaMundo.php\n$ git hist --all\n*   2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -&gt; main) [Sergio Gomez]\n*\\\n| * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez]\n| * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez]\n|/\n* 9c85275 2013-06-16 | Programa interactivo (main) [Sergio G\u00f3mez]\n* c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez]\n* 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez]\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"\n   commit id: \"c3e65d0\"\n   commit id: \"9c85275\"\n   branch hola\n   commit id: \"6932156\"\n   commit id: \"9862f33\"\n   checkout main\n   merge hola id: \"2eab8ca\"</code></pre> <p>En la siguiente imagen se puede ver la diferencia:</p> <p></p>"},{"location":"referencias/","title":"Referencias","text":"<ul> <li>Documentaci\u00f3n oficial en ingl\u00e9s.</li> <li>Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta).</li> <li>Curso de Git (ingl\u00e9s). La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso.</li> <li>Curso interactivo de Git (ingl\u00e9s).</li> <li>P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s).</li> <li>Chuleta con las \u00f3rdenes m\u00e1s usuales de Git.</li> <li>Gitmagic (ingles y espa\u00f1ol). Otro manual de Git</li> <li>Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git .</li> <li>Curso detallado y gratuito sobre Git y github</li> <li>Otra guia r\u00e1pida de git</li> <li>Gu\u00eda de estilos seg\u00fan Udacity</li> <li>Flujo de trabajo de Gitflow</li> </ul>"},{"location":"usoavanzado/","title":"Uso avanzado de Git","text":""},{"location":"usoavanzado/#deshacer-cambios","title":"Deshacer cambios","text":""},{"location":"usoavanzado/#deshaciendo-cambios-antes-de-la-fase-de-staging","title":"Deshaciendo cambios antes de la fase de staging.","text":"<p>Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos:</p> <pre><code>$ git checkout main\nPrevious HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto\nSwitched to branch 'main'\n</code></pre> <p>Modificamos hola.php de la siguiente manera:</p> <pre><code>&lt;?php\n// Este comentario est\u00e1 mal y hay que borrarlo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y comprobamos:</p> <pre><code>$ git status\n# On branch main\n# Changes not staged for commit:\n#   (use \"git add &lt;file&gt;...\" to update what will be committed)\n#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos:</p> <pre><code>$ git checkout hola.php\n$ git status\n# On branch main\nnothing to commit, working directory clean\n$ cat hola.php\n&lt;?php\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre>"},{"location":"usoavanzado/#deshaciendo-cambios-antes-del-commit","title":"Deshaciendo cambios antes del commit","text":"<p>Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al staging (sin hacer commit). As\u00ed que volvemos a modificar hola.php igual que la anterior ocasi\u00f3n:</p> <pre><code>&lt;?php\n// Este comentario est\u00e1 mal y hay que borrarlo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y lo a\u00f1adimos al staging</p> <pre><code>$ git add hola.php\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n#\n#   modified:   hola.php\n#\n</code></pre> <p>De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio:</p> <pre><code>$ git reset HEAD hola.php\nUnstaged changes after reset:\nM   hola.php\n$ git status\n# On branch main\n# Changes not staged for commit:\n#   (use \"git add &lt;file&gt;...\" to update what will be committed)\n#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git checkout hola.php\n</code></pre> <p>Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos: uno para borrar los datos del staging y otro para restaurar la copia de trabajo.</p>"},{"location":"usoavanzado/#deshaciendo-commits-no-deseados","title":"Deshaciendo commits no deseados.","text":"<p>Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden <code>git revert</code>. Modificamos otra vez el archivo como antes:</p> <pre><code>&lt;?php\n// Este comentario est\u00e1 mal y hay que borrarlo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Pero ahora s\u00ed hacemos commit:</p> <pre><code>$ git add hola.php\n$ git commit -m \"Ups... este commit est\u00e1 mal.\"\nmain 5a5d067] Ups... este commit est\u00e1 mal\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre> <p>Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden <code>git revert</code>:</p> <pre><code>$ git revert HEAD --no-edit\n[main 817407b] Revert \"Ups... este commit est\u00e1 mal\"\n1 file changed, 1 insertion(+), 1 deletion(-)\n$ git hist\n* 817407b 2013-06-16 | Revert \"Ups... este commit est\u00e1 mal\" (HEAD, main) [Sergio G\u00f3mez]\n* 5a5d067 2013-06-16 | Ups... este commit est\u00e1 mal [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"5a5d067\"\n   commit id: \"817407b\"</code></pre>"},{"location":"usoavanzado/#borrar-commits-de-una-rama","title":"Borrar commits de una rama","text":"<p>El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden <code>git reset</code>.</p> <pre><code>$ git reset --hard v1\nHEAD is now at fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n$ git hist\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, tag: v1, main) [Sergio G\u00f3me\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"</code></pre> <p>El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final.</p> <p>Danger</p> <p>La orden reset es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo, sobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios lo cual puede provocar problemas de sincronizaci\u00f3n.</p>"},{"location":"usoavanzado/#modificar-un-commit","title":"Modificar un commit","text":"<p>Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos nuestro archivo hola.php de la siguiente manera:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y lo confirmamos:</p> <pre><code>$ git commit -a -m \"A\u00f1adido el autor del programa\"\n[main cf405c1] A\u00f1adido el autor del programa\n 1 file changed, 1 insertion(+)\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"cf405c1\"</code></pre> <p>Tip</p> <p>El par\u00e1metro <code>-a</code> hace un <code>git add</code> antes de hacer commit de todos los archivos modificados  o borrados (de los nuevos no), con lo que nos ahorramos un paso.</p> <p>Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo:</p> <pre><code>&lt;?php\n// Autor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y en esta ocasi\u00f3n usamos <code>commit --amend</code> que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual:</p> <pre><code>$ git add hola.php\n$ git commit --amend -m \"A\u00f1adido el autor del programa y su email\"\n[main 96a39df] A\u00f1adido el autor del programa y su email\n 1 file changed, 1 insertion(+)\n$ git hist\n* 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email (HEAD, main) [Sergio G\u00f3mez]\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"</code></pre> <p>Danger</p> <p>Nunca modifiques un commit que ya hayas sincronizado con otro repositorio o que hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas problemas de sincronizaci\u00f3n.</p>"},{"location":"usoavanzado/#moviendo-y-borrando-archivos","title":"Moviendo y borrando archivos","text":""},{"location":"usoavanzado/#mover-un-archivo-a-otro-directorio-con-git","title":"Mover un archivo a otro directorio con git","text":"<p>Para mover archivos usaremos la orden <code>git mv</code>:</p> <pre><code>$ mkdir lib\n$ git mv hola.php lib\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n#\n#   renamed:    hola.php -&gt; lib/hola.php\n#\n</code></pre>"},{"location":"usoavanzado/#mover-y-borrar-archivos","title":"Mover y borrar archivos.","text":"<p>Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema mv y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes:</p> <pre><code>$ mkdir lib\n$ mv hola.php lib\n$ git add lib/hola.php\n$ git rm hola.php\n</code></pre> <p>Y, ahora s\u00ed, ya podemos guardar los cambios:</p> <pre><code>$ git commit -m \"Movido hola.php a lib.\"\n[main 8c2a509] Movido hola.php a lib.\n 1 file changed, 0 insertions(+), 0 deletions(-)\n rename hola.php =&gt; lib/hola.php (100%)\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"\n   commit id: \"96a39df\"\n   commit id: \"8c2a509\"</code></pre>"},{"location":"usobasico/","title":"Uso b\u00e1sico de Git","text":""},{"location":"usobasico/#crear-un-proyecto","title":"Crear un proyecto","text":""},{"location":"usobasico/#crear-un-programa-hola-mundo","title":"Crear un programa \"Hola Mundo\"","text":"<p>Creamos un directorio donde colocar el c\u00f3digo</p> <pre><code>$ mkdir curso-de-git\n$ cd curso-de-git\n</code></pre> <p>Creamos un fichero <code>hola.php</code> que muestre Hola Mundo.</p> <pre><code>&lt;?php\necho \"Hola Mundo\\n\";\n</code></pre>"},{"location":"usobasico/#crear-el-repositorio","title":"Crear el repositorio","text":"<p>Para crear un nuevo repositorio se usa la orden <code>git init</code></p> <pre><code>$ git init\nInitialized empty Git repository in /home/cc0gobas/git/curso-de-git/.git/\n</code></pre>"},{"location":"usobasico/#anadir-la-aplicacion","title":"A\u00f1adir la aplicaci\u00f3n","text":"<p>Vamos a almacenar el archivo que hemos creado en el repositorio para poder trabajar, despu\u00e9s explicaremos para qu\u00e9 sirve cada orden.</p> <pre><code>$ git add hola.php\n$ git commit -m \"Creaci\u00f3n del proyecto\"\n[main (root-commit) e19f2c1] Creaci\u00f3n del proyecto\n 1 file changed, 2 insertions(+)\n create mode 100644 hola.php\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"</code></pre>"},{"location":"usobasico/#comprobar-el-estado-del-repositorio","title":"Comprobar el estado del repositorio","text":"<p>Con la orden <code>git status</code> podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio.</p> <pre><code>$ git status\n# On branch main\nnothing to commit (working directory clean)\n</code></pre> <p>Si modificamos el archivo <code>hola.php</code>:</p> <pre><code>&lt;?php\n@print \"Hola {$argv[1]}\\n\";\n</code></pre> <p>Y volvemos a comprobar el estado del repositorio:</p> <pre><code>$ git status\n# On branch main\n# Changes not staged for commit:\n#   (use \"git add &lt;file&gt;...\" to update what will be committed)\n#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre>"},{"location":"usobasico/#anadir-cambios","title":"A\u00f1adir cambios","text":"<p>Con la orden <code>git add</code> indicamos a git que prepare los cambios para que sean almacenados.</p> <pre><code>$ git add hola.php\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n#\n#   modified:   hola.php\n#\n</code></pre>"},{"location":"usobasico/#confirmar-los-cambios","title":"Confirmar los cambios","text":"<p>Con la orden <code>git commit</code> confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio.</p> <pre><code>$ git commit -m \"Parametrizaci\u00f3n del programa\"\n[main efc252e] Parametrizaci\u00f3n del programa\n 1 file changed, 1 insertion(+), 1 deletion(-)\n$ git status\n# On branch main\nnothing to commit (working directory clean)\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"</code></pre>"},{"location":"usobasico/#diferencias-entre-workdir-y-staging","title":"Diferencias entre workdir y staging.","text":"<p>Modificamos nuestra aplicaci\u00f3n para que soporte un par\u00e1metro por defecto y a\u00f1adimos los cambios.</p> <pre><code>&lt;?php\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Este vez a\u00f1adimos los cambios a la fase de staging pero sin confirmarlos (commit).</p> <pre><code>git add hola.php\n</code></pre> <p>Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho.</p> <pre><code>&lt;?php\n// El nombre por defecto es Mundo\n$nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n@print \"Hola, {$nombre}\\n\";\n</code></pre> <p>Y vemos el estado en el que est\u00e1 el repositorio</p> <pre><code>$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n#\n#   modified:   hola.php\n#\n# Changes not staged for commit:\n#   (use \"git add &lt;file&gt;...\" to update what will be committed)\n#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n#\n#   modified:   hola.php\n#\n</code></pre> <p>Podemos ver como aparecen el archivo hola.php dos veces. El primero est\u00e1 preparado para ser confirmado y est\u00e1 almacenado en la zona de staging. El segundo indica que el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo (workdir).</p> <p>Warning</p> <p>Si volvieramos a hacer un <code>git add hola.php</code> sobreescribir\u00edamos los cambios previos que hab\u00eda en la zona de staging.</p> <p>Almacenamos los cambios por separado:</p> <pre><code>$ git commit -m \"Se a\u00f1ade un par\u00e1metro por defecto\"\n[main 3283e0d] Se a\u00f1ade un par\u00e1metro por defecto\n 1 file changed, 2 insertions(+), 1 deletion(-)\n$ git status\n# On branch main\n# Changes not staged for commit:\n#   (use \"git add &lt;file&gt;...\" to update what will be committed)\n#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n#\n#   modified:   hola.php\n#\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n$ git add .\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n#\n#   modified:   hola.php\n#\n$ git commit -m \"Se a\u00f1ade un comentario al cambio del valor por defecto\"\n[main fd4da94] Se a\u00f1ade un comentario al cambio del valor por defecto\n 1 file changed, 1 insertion(+)\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\"\n   commit id: \"fd4da94\"</code></pre> <p>Info</p> <p>El valor \".\" despues de <code>git add</code> indica que se a\u00f1adan todos los archivos de forma recursiva.</p> <p>Warning</p> <p>Cuidado cuando uses <code>git add .</code> aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir.</p>"},{"location":"usobasico/#ignorando-archivos","title":"Ignorando archivos","text":"<p>La orden <code>git add .</code> o <code>git add nombre_directorio</code> es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible.</p> <p>Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de <code>C/C++</code>, los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen.</p> <p>Para indicarle a git que debe ignorar un archivo, se puede crear un fichero llamado .gitignore, bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente:</p> <pre><code># .gitignore\ndir1/           # ignora todo lo que contenga el directorio dir1\n!dir1/info.txt  # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda)\ndir2/*.txt      # ignora todos los archivos txt que hay en el directorio dir2\ndir3/**/*.txt   # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios\n*.o             # ignora todos los archivos con extensi\u00f3n .o en todos los directorios\n</code></pre> <p>Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un <code>.gitignore</code> apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en https://github.com/github/gitignore</p>"},{"location":"usobasico/#ignorando-archivos-globalmente","title":"Ignorando archivos globalmente","text":"<p>Si bien, los archivos que hemos metido en <code>.gitignore</code>, deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un gitignore que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo (<code>*~</code>, <code>.nfs*</code>) y los que generan los entornos de desarrollo.</p> <p>Para indicar a git que queremos tener un fichero de gitignore global, tenemos que configurarlo con la siguiente orden:</p> <pre><code>git config --global core.excludesfile $HOME/.gitignore_global\n</code></pre> <p>Ahora podemos crear un archivo llamado <code>.gitignore_global</code> en la ra\u00edz de nuestra cuenta con este contenido:</p> <pre><code># Compiled source #\n###################\n*.com\n*.class\n*.dll\n*.exe\n*.o\n*.so\n\n# Packages #\n############\n# it's better to unpack these files and commit the raw source\n# git has its own built in compression methods\n*.7z\n*.dmg\n*.gz\n*.iso\n*.jar\n*.rar\n*.tar\n*.zip\n\n# Logs and databases #\n######################\n*.log\n*.sql\n*.sqlite\n\n# OS generated files #\n######################\n.DS_Store\n.DS_Store?\n._*\n.Spotlight-V100\n.Trashes\nehthumbs.db\nThumbs.db\n*~\n*.swp\n\n# IDEs               #\n######################\n.idea\n.settings/\n.classpath\n.project\n</code></pre>"},{"location":"usobasico/#trabajando-con-el-historial","title":"Trabajando con el historial","text":""},{"location":"usobasico/#observando-los-cambios","title":"Observando los cambios","text":"<p>Con la orden <code>git log</code> podemos ver todos los cambios que hemos hecho:</p> <pre><code>$ git log\ncommit fd4da946326fbe8b24e89282ad25a71721bf40f6\nAuthor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nDate:   Sun Jun 16 12:51:01 2013 +0200\n\n    Se a\u00f1ade un comentario al cambio del valor por defecto\n\ncommit 3283e0d306c8d42d55ffcb64e456f10510df8177\nAuthor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nDate:   Sun Jun 16 12:50:00 2013 +0200\n\n    Se a\u00f1ade un par\u00e1metro por defecto\n\ncommit efc252e11939351505a426a6e1aa5bb7dc1dd7c0\nAuthor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nDate:   Sun Jun 16 12:13:26 2013 +0200\n\n    Parametrizaci\u00f3n del programa\n\ncommit e19f2c1701069d9d1159e9ee21acaa1bbc47d264\nAuthor: Sergio G\u00f3mez &lt;sergio@uco.es&gt;\nDate:   Sun Jun 16 11:55:23 2013 +0200\n\n    Creaci\u00f3n del proyecto\n</code></pre> <p>Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros:</p> <pre><code>$ git log --oneline\nfd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto\n3283e0d Se a\u00f1ade un par\u00e1metro por defecto\nefc252e Parametrizaci\u00f3n del programa\ne19f2c1 Creaci\u00f3n del proyecto\ngit log --oneline --max-count=2\ngit log --oneline --since='5 minutes ago'\ngit log --oneline --until='5 minutes ago'\ngit log --oneline --author=sergio\ngit log --oneline --all\n</code></pre> <p>Una versi\u00f3n muy \u00fatil de <code>git log</code> es la siguiente, pues nos permite ver en que lugares est\u00e1 main y HEAD, entre otras cosas:</p> <pre><code>$ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, main) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre>"},{"location":"usobasico/#crear-alias","title":"Crear alias","text":"<p>Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello podemos configurar nuestro entorno con la orden <code>git config</code> de la siguiente manera:</p> <pre><code>git config --global alias.hist \"log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short\"\n</code></pre> <p>Example</p> <p>Puedes configurar incluso alias para abreviar comandos. Algunos ejemplos de alias \u00fatiles:</p> <pre><code>git config --global alias.br branch\ngit config --global alias.co checkout\ngit config --global alias.ci commit\ngit config --global alias.st \"status -u\"\ngit config --global alias.cane \"commit --amend --no-edit\"\n</code></pre>"},{"location":"usobasico/#recuperando-versiones-anteriores","title":"Recuperando versiones anteriores","text":"<p>Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden <code>git checkout</code>.</p> <pre><code>$ git checkout e19f2c1\nNote: checking out 'e19f2c1'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b new_branch_name\n\nHEAD is now at e19f2c1... Creaci\u00f3n del proyecto\n$ cat hola.php\n&lt;?php\necho \"Hello, World\\n\";\n</code></pre> <p>El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos.</p>"},{"location":"usobasico/#volver-a-la-ultima-version-de-la-rama-main","title":"Volver a la \u00faltima versi\u00f3n de la rama main.","text":"<p>Usamos <code>git checkout</code> indicando el nombre de la rama:</p> <pre><code>$ git checkout main\nPrevious HEAD position was e19f2c1... Creaci\u00f3n del proyecto\n</code></pre>"},{"location":"usobasico/#etiquetando-versiones","title":"Etiquetando versiones","text":"<p>Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden <code>git tag</code>.</p> <pre><code>$ git tag v1\n</code></pre> <p>Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores <code>^</code> o <code>~</code> que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes:</p> <pre><code>$ git checkout v1^\n$ git checkout v1~1\n$ git tag v1-beta\n</code></pre> <p>Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes.</p> <pre><code>$ git tag\nv1\nv1-beta\n</code></pre> <p>Y para verlas en el historial:</p> <pre><code>$ git hist main --all\n* fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1, main) [Sergio G\u00f3mez]\n* 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (HEAD, tag: v1-beta) [Sergio G\u00f3mez]\n* efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez]\n* e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]\n</code></pre> <pre><code>gitGraph:\n   commit id: \"e19f2c1\"\n   commit id: \"efc252e\"\n   commit id: \"3283e0d\" tag: \"v1-beta\"\n   commit id: \"fd4da94\" tag: \"v1\"</code></pre>"},{"location":"usobasico/#borrar-etiquetas","title":"Borrar etiquetas","text":"<p>Para borrar etiquetas:</p> <pre><code>git tag -d nombre_etiqueta\n</code></pre>"},{"location":"usobasico/#visualizar-cambios","title":"Visualizar cambios","text":"<p>Para ver los cambios que se han realizado en el c\u00f3digo usamos la orden <code>git diff</code>. La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden <code>git add</code>. Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo:</p> <pre><code>$ git diff v1-beta v1\ndiff --git a/hola.php b/hola.php\nindex a31e01f..25a35c0 100644\n--- a/hola.php\n+++ b/hola.php\n@@ -1,3 +1,4 @@\n &lt;?php\n+// El nombre por defecto es Mundo\n $nombre = isset($argv[1]) ? $argv[1] : \"Mundo\";\n @print \"Hola, {$nombre}\\n\";\n</code></pre>"}]}